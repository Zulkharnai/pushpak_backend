"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Cursor = void 0;
const encode_object_1 = require("@batterii/encode-object");
const lodash_1 = __importDefault(require("lodash"));
const invalid_cursor_error_js_1 = require("./invalid-cursor-error.js");
const nani_1 = require("nani");
class Cursor {
    constructor(query, sort, values) {
        this.query = query;
        this.sort = sort;
        this.values = values;
    }
    static fromObject(obj) {
        return new Cursor(obj.q, obj.s, obj.v);
    }
    static validateObject(value) {
        if (!lodash_1.default.isObjectLike(value)) {
            throw new invalid_cursor_error_js_1.InvalidCursorError("Cursor is not object-like", { info: { cursor: value } });
        }
        if (!lodash_1.default.isString(value.q)) {
            throw new invalid_cursor_error_js_1.InvalidCursorError("Cursor 'q' is not a string", { info: { q: value.q } });
        }
        if (!lodash_1.default.isString(value.s)) {
            throw new invalid_cursor_error_js_1.InvalidCursorError("Cursor 's' is not a string", { info: { s: value.s } });
        }
        if (value.v !== undefined && !lodash_1.default.isArray(value.v)) {
            throw new invalid_cursor_error_js_1.InvalidCursorError("Cursor 'v' is not an array", { info: { v: value.v } });
        }
        return value;
    }
    static parse(str) {
        let obj;
        try {
            obj = (0, encode_object_1.decodeObject)(str);
        }
        catch (err) {
            if (!(0, nani_1.is)(err, encode_object_1.InvalidJsonError))
                throw err;
            throw new invalid_cursor_error_js_1.InvalidCursorError({
                shortMessage: "Cursor contains invalid JSON",
                cause: err,
                info: { cursor: str },
            });
        }
        return Cursor.fromObject(Cursor.validateObject(obj));
    }
    toObject() {
        const obj = { q: this.query, s: this.sort };
        if (this.values)
            obj.v = this.values;
        return obj;
    }
    serialize() {
        return (0, encode_object_1.encodeObject)(this.toObject());
    }
}
exports.Cursor = Cursor;
//# sourceMappingURL=cursor.js.map