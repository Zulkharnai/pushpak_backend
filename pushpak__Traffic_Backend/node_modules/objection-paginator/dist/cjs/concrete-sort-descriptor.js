"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConcreteSortDescriptor = void 0;
const sort_descriptor_js_1 = require("./sort-descriptor.js");
const get_error_class_js_1 = require("./get-error-class.js");
const lodash_1 = __importDefault(require("lodash"));
const column_js_1 = require("./column.js");
const configuration_error_js_1 = require("./configuration-error.js");
const object_path_1 = __importDefault(require("object-path"));
class ConcreteSortDescriptor {
    constructor(descriptor) {
        if (lodash_1.default.isString(descriptor))
            descriptor = { column: descriptor };
        lodash_1.default.defaults(this, descriptor, {
            columnType: sort_descriptor_js_1.ColumnType.String,
            nullable: false,
            direction: sort_descriptor_js_1.SortDirection.Ascending,
            valuePath: descriptor.column,
        });
        column_js_1.Column.validate(this.column);
        if (!Object.values(sort_descriptor_js_1.ColumnType).includes(this.columnType)) {
            throw new configuration_error_js_1.ConfigurationError(`Unknown column type '${this.columnType}'`);
        }
        if (!Object.values(sort_descriptor_js_1.SortDirection).includes(this.direction)) {
            throw new configuration_error_js_1.ConfigurationError(`Unknown sort direction '${this.direction}'`);
        }
    }
    get order() {
        const { direction } = this;
        if (direction === sort_descriptor_js_1.SortDirection.DescendingNullsLast) {
            return sort_descriptor_js_1.SortDirection.Descending;
        }
        return direction;
    }
    get nullOrder() {
        const { direction } = this;
        if (direction === sort_descriptor_js_1.SortDirection.DescendingNullsLast) {
            return sort_descriptor_js_1.SortDirection.Ascending;
        }
        return direction;
    }
    get operator() {
        return this.direction === sort_descriptor_js_1.SortDirection.Ascending ? ">" : "<";
    }
    checkCursorValue(value) {
        switch (this.columnType) {
            case sort_descriptor_js_1.ColumnType.String:
                return lodash_1.default.isString(value);
            case sort_descriptor_js_1.ColumnType.Integer:
                return lodash_1.default.isInteger(value);
            case sort_descriptor_js_1.ColumnType.Float:
                return lodash_1.default.isFinite(value);
            case sort_descriptor_js_1.ColumnType.Boolean:
                return lodash_1.default.isBoolean(value);
            case sort_descriptor_js_1.ColumnType.Date:
                return value instanceof Date || lodash_1.default.isString(value);
            default:
                return false;
        }
    }
    validateCursorValue(value, validationCase) {
        if (value === null) {
            if (!this.nullable) {
                throw new ((0, get_error_class_js_1.getErrorClass)(validationCase))("Cursor value is null, but column is not nullable", { info: { value: null } });
            }
        }
        else if (!this.checkCursorValue(value)) {
            throw new ((0, get_error_class_js_1.getErrorClass)(validationCase))("Cursor value does not match its column type", { info: { value, columnType: this.columnType } });
        }
        const validateResult = this.validate ? this.validate(value) : true;
        let isValid;
        let msg;
        if (lodash_1.default.isString(validateResult)) {
            isValid = false;
            msg = validateResult;
        }
        else {
            isValid = validateResult;
            msg = "Invalid cursor value";
        }
        if (isValid)
            return value;
        throw new ((0, get_error_class_js_1.getErrorClass)(validationCase))(msg, { info: { value } });
    }
    getCursorValue(entity) {
        let value = object_path_1.default.get(entity, this.valuePath);
        if (value === undefined)
            value = null;
        return this.validateCursorValue(value, get_error_class_js_1.ValidationCase.Configuration);
    }
    getRawColumn(qry) {
        return column_js_1.Column.toRaw(this.column, qry);
    }
}
exports.ConcreteSortDescriptor = ConcreteSortDescriptor;
//# sourceMappingURL=concrete-sort-descriptor.js.map